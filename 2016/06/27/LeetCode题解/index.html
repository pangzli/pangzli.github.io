<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="LeetCode上算法题的思路和代码实现。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode题解">
<meta property="og:url" content="http://yoursite.com/2016/06/27/LeetCode题解/index.html">
<meta property="og:site_name" content="胖子李">
<meta property="og:description" content="LeetCode上算法题的思路和代码实现。">
<meta property="og:image" content="https://leetcode.com/static/images/problemset/island.png">
<meta property="og:updated_time" content="2017-03-09T15:42:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode题解">
<meta name="twitter:description" content="LeetCode上算法题的思路和代码实现。">
<meta name="twitter:image" content="https://leetcode.com/static/images/problemset/island.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/06/27/LeetCode题解/"/>

  <title> LeetCode题解 | 胖子李 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?0e848dc3bf106cbfb59929b6254ac0d0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">胖子李</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">一个人的命运啊，当然要靠自我奋斗。但是，也要考虑到历史的行程。（手动滑稽</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                LeetCode题解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-27T00:00:00+08:00" content="2016-06-27">
              2016-06-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/27/LeetCode题解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/27/LeetCode题解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
		  
          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>LeetCode上算法题的思路和代码实现。</p>
<a id="more"></a>
<h2 id="Reverse-String"><a href="#Reverse-String" class="headerlink" title="Reverse String"></a>Reverse String</h2><p>Write a function that takes a string as input and returns the string reversed.</p>
<p>Example:<br>Given s = “hello”, return “olleh”.</p>
<pre><code>class Solution {
public:
    string reverseString(string s) {
        if(s == &quot;&quot;)return &quot;&quot;;
        char temp;
        int len = s.length();
        for(int i=0;i&lt;len/2;i++)
        {
            temp = s[i];
            s[i]=s[s.length()-i-1];
            s[s.length()-i-1] = temp;
        }
        return s;     
    }
};
</code></pre><h2 id="Nim-Game"><a href="#Nim-Game" class="headerlink" title="Nim Game"></a>Nim Game</h2><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>可以拿1-3个石子，拿到最后一个石子的人获胜，假设你是第一个拿石子的人。</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>
<p>分析：</p>
<blockquote>
<ul>
<li>0 块石子 - false</li>
<li>1 块石子 - true</li>
<li>2 块石子 - true</li>
<li>3 块石子 - true</li>
<li>4 块石子 - false</li>
<li>5 块石子 - true</li>
<li>6 块石子 - true</li>
<li>7 块石子 - true</li>
<li>8 块石子 - false</li>
</ul>
</blockquote>
<p>发现，当是4块时，这时要拿石子的人不管拿1-3中的几块，都会失败</p>
<p>而总数是5块时，可以拿1块让总数变成4块，总数是6块时，可以拿2块让总数变成4块…..</p>
<p>以此类推，发现当4的倍数时失败，其余情况成功。</p>
<pre><code>class Solution {
public:
    bool canWinNim(int n) {
        if(n%4 == 0)
        return false;
        else 
        return true;
    }
};
</code></pre><h2 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h2><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>给定一个整形数组，只有一个数字出现了一次，其余的都出现了两次，找到这个只出现了一次的数组。</p>
<p>这个题第一次看到的时候，我是这样做的：</p>
<pre><code>class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {

        int temp;

        for (int i=0;i&lt;nums.size();i++)
        {
            temp = nums[i];
            bool flag = false;
            for(int j=0;j&lt;nums.size();j++)
            {
                if(j==i)continue;
                if(temp == nums[j])
                flag = true;
            }

            if(flag == false)
                break;

        }
            return temp;
    }
};
</code></pre><p>时间复杂度为O(n^2)，结果是：Time Limit Exceeded</p>
<p>后来发现有两个公式：</p>
<blockquote>
<ul>
<li>a ⊕ a = 0</li>
<li>a ⊕ 0 = a</li>
</ul>
</blockquote>
<p>可以写出一段特别简单的代码：</p>
<pre><code>class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int temp=0;
        for(int i=0;i&lt;nums.size();i++)
        {
            temp = temp xor nums[i];
        }
        return temp;  
    }
};
</code></pre><p>时间复杂度为O(n)。</p>
<h2 id="Add-Digits"><a href="#Add-Digits" class="headerlink" title="Add Digits"></a>Add Digits</h2><p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
<p>For example:</p>
<p>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.    </p>
<p>我用了递归的方法，当结果是两位数时继续相加，当为个位数是开始返回。</p>
<pre><code>class Solution {
public:
    int addDigits(int num) {
        if(num&gt;=10)
            return addDigits(num/10+num%10);
        else
            return num;
    }
};
</code></pre><p>后来，在网上找更优的解法，发现下面这个算法。</p>
<pre><code>// Let&apos;s observe the pattern
//    1    1
//    2    2
//    ... ...
//    8    8    
//    9    9    
//    10    1
//    11    2
//    12    3    
//    ... ...
//    17    8
//    18    9
//    19    1
//    20    2
//    ...  ...
// It looks most of number just simply %9 is the answer, 
// but there are some edge cases.
//    9%9=0 but we need 9. 
//    18%9=0 but we need 9
// so we can find the solution is:
//    1) num &lt;=9, return num
//    2) num &gt; 9, reutrn num%9 if num%9&gt;0
//                return 9 if num%9 ==0
int addDigits03(int num) {
    return num &gt;9 ? ((num %9)==0 ? 9:num%9) : num;
}

//But actually, we can use (num-1)%9 + 1 to make all cases right.
int addDigits04(int num){
    return (num - 1) % 9 + 1;
}

//This solution is similar with pervious solution.
int addDigits05(int num){
    return num - 9 * ((num - 1)/9);
}
</code></pre><p>上面这三个算法，都是同一种思路，发现当给定的数不是9的倍数时，结果是该数%9的结果，否则结果是9。</p>
<h2 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {

        if(root==NULL)
        return 0;

        int left = maxDepth(root-&gt;left);
        int right = maxDepth(root-&gt;right);

        if(left&gt;right)
            return left+1;
        else
            return right+1;
    }
};
</code></pre><p>利用递归的方法，每层的深度是左子树与右子树中高的那个加一。</p>
<h2 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h2><p>Reverse a singly linked list.</p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<p>迭代方法（iteratively）：</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head){

        if(head==NULL||head-&gt;next==NULL) return head;

        ListNode *newN = head; // 新排序好的第一个
        ListNode *oldN = newN-&gt;next; // 待排序的第一个
        head -&gt; next = NULL;  // 将头结点的next清空
        ListNode *tempN = NULL; // 定义一个临时变量存储oldN的下一个

        while(oldN) // 不断将结点的next反向
        {
            tempN = oldN-&gt;next;
            oldN-&gt;next = newN;
            newN = oldN;
            oldN = tempN;
        }

        return newN;
    }
};
</code></pre><p>递归方法（recursively）：</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head){
        if (head==NULL || head-&gt;next==NULL) return head;

        ListNode *h = reverseList(head-&gt;next);
        head-&gt;next-&gt;next = head;
        head-&gt;next = NULL;

        return h;
    }
};
</code></pre><p>利用栈实现：</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* pHead) {
        if(!pHead || !pHead-&gt;next) return pHead;
        stack&lt;ListNode *&gt; s;
        ListNode *node = pHead;
        while(node-&gt;next){
            s.push(node);
            node = node-&gt;next;
        }

        ListNode *newHead = node;
        while(!s.empty()){
            node-&gt;next = s.top();
            node = node-&gt;next;
            s.pop();
        }
        node-&gt;next = NULL;
        return newHead;
    }
};
</code></pre><p>递归方法简单易懂。</p>
<h2 id="Counting-Bits"><a href="#Counting-Bits" class="headerlink" title="Counting Bits"></a>Counting Bits</h2><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>计算从0到num一共num+1个数，每个数的二进制形式中1的个数，组成一个数组。</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; countBits(int num) {
        vector&lt;int&gt; temp(num+1, 0);

        for (int i=0;i&lt;num+1;i++)
        {
            temp[i]=numOf1(i);
        }

        return temp;

    }
    int numOf1(int n) // 剑指offer书里介绍的一种非常巧妙地计算一个二进制数中1的个数的算法
    {
        int count = 0;
        while(n)
        {
            ++ count;
            n = n &amp; (n-1);
        }

        return count;
    }
};
</code></pre><h2 id="Invert-Binary-Tree"><a href="#Invert-Binary-Tree" class="headerlink" title="Invert Binary Tree"></a>Invert Binary Tree</h2><p>Invert a binary tree.</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9
</code></pre><p>to</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1
</code></pre><p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.（2333333333</p>
<p>递归算法：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==NULL)return root;

        TreeNode *temp = invertTree(root-&gt;left); // 将左边的保存
        root-&gt;left = invertTree(root-&gt;right); // 左右互换
        root-&gt;right = temp;

        return root;   
    }
};
</code></pre><h2 id="Sum-of-Two-Integers"><a href="#Sum-of-Two-Integers" class="headerlink" title="Sum of Two Integers"></a>Sum of Two Integers</h2><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example:<br>Given a = 1 and b = 2, return 3.</p>
<p>要求不使用+或者-实现两个整数的加法运算，可以运用全加器的思想实现这个算法。<br>对于单独的两个一位二进制数，有两个输出，一个是本位输出，一个是进位输出。</p>
<pre><code>class Solution {
public:
    int getSum(int a, int b) {
        while(b)
        {
            int c = a &amp; b; //进位
            a = a ^ b; //本位
            b = c&lt;&lt;1; // 进位左移进入下一位的运算
        }
        return a;
    }
};
</code></pre><p>ex:a=0101(5),b=0011(3)</p>
<ul>
<li>c=0001,a=0110,b=0010</li>
<li>c=0010,a=0100,b=0100</li>
<li>c=0100,a=0000,b=1000</li>
<li>c=0000,a=1000,b=0000</li>
</ul>
<p>返回1000(8)</p>
<h2 id="Single-Number-III"><a href="#Single-Number-III" class="headerlink" title="Single Number III"></a>Single Number III</h2><p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>我们已经知道,假如题目为只有一个数为单次,其余都为两次时,可以用result = result ^ nums[i]找出result,所以本题中当有两个数为单次时,全部异或的结果allxor为a ^ b.</p>
<p>这时设一个标记tag,tag为a和b从低位开始,第一个不相等的那一位(例如a:0101和b:0011,tag为0010),由这个标记可以将整个数组分为需要的两大部分,然后由异或得出两个结果a和b.</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {
        int allxor = 0;
        for(int i=0;i&lt;nums.size();i++)
        {
            allxor = allxor ^ nums[i];
        }

        int tag = 1;
        while((allxor&amp;tag) == 0)
        {
            tag = tag&lt;&lt;1;
        }

        int a = 0;
        int b = 0;
        for(int i=0;i&lt;nums.size();i++)
        {
            if(tag&amp;nums[i])
            {
                a = a ^ nums[i];
            }
            else
            {
                b = b ^ nums[i];
            }
        }

        vector&lt;int&gt; result;
        result.push_back(a);
        result.push_back(b);

        return result;
    }
};
</code></pre><h2 id="Move-Zeroes"><a href="#Move-Zeroes" class="headerlink" title="Move Zeroes"></a>Move Zeroes</h2><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p>Note:</p>
<p>You must do this in-place without making a copy of the array.(空间复杂度O(1))</p>
<p>Minimize the total number of operations.</p>
<p>这个题要求空间复杂度为O(1),就不能创建一个新的空间生成新数组,只能在原来的空间上进行操作,可以设两个标记p1,p2.  p1为原顺序,p2为不为零的数的顺序,每当遇到0,p2++,就是将后面的所有数提前一个,当所有这种操作完成后,数组中就不存在0,然后将0补在数组的后面.</p>
<pre><code>class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int p1 = 0, p2 = 0;

        while(nums[p1] != 0 &amp;&amp; p1 &lt; nums.size()) //找到第一个为0的数的位置
        {
            p1++;
        }

        for(p2 = p1; p2&lt;nums.size(); p2++) //每当遇到0,p2++,将后面的数提前一位
        {
            if(nums[p2] == 0) continue;
            nums[p1] = nums[p2];
            p1++;
        }

        while(p1&lt;nums.size()) //补0
        {
            nums[p1] = 0;
            p1++;
        }
    }
};
</code></pre><h2 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a>Intersection of Two Arrays</h2><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example:</p>
<p>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>
<p>Note:</p>
<ul>
<li>Each element in the result must be unique.</li>
<li>The result can be in any order.</li>
</ul>
<p>在C++中,STL定义了许多容器,将vector转为set可以将重复的元素去除掉,所以本题可以用两个set,然后将set重新转为vector</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        set&lt;int&gt; s1;
        set&lt;int&gt; s2;
        vector&lt;int&gt; result;

        for(int i = 0; i &lt; nums1.size(); i++)
        {
            s1.insert(nums1[i]);
        }

        for(int i = 0; i &lt; nums2.size(); i++)
        {
            if (s1.find(nums2[i]) != s1.end())
            {
                s2.insert(nums2[i]);
            }
        }

        for(set&lt;int&gt;::iterator it = s2.begin(); it != s2.end(); it++)
        {
            result.push_back(*it);
        }

        return result;
    }
};
</code></pre><h2 id="Delete-Node-in-a-Linked-List"><a href="#Delete-Node-in-a-Linked-List" class="headerlink" title="Delete Node in a Linked List"></a>Delete Node in a Linked List</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val = node-&gt;next-&gt;val;
        node-&gt;next = node-&gt;next-&gt;next;
    }
};
</code></pre><h2 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a>Product of Array Except Self</h2><p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Solve it without division and in O(n).</p>
<p>For example, given [1,2,3,4], return [24,12,8,6].</p>
<p>Follow up:<br>Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)</p>
<p>题目限定了我们不能用除法,时间复杂度为O(n),空间复杂度为O(1),可以先正序遍历一遍数组，每一个位置上存这个位置之前所有数字的乘积。那么一遍下来，最后一个位置上的数字是之前所有数字之积,此时再后序遍历数组，每个位置上的数在乘以后面所有数字之积，对于最后一个位置来说，由于后面没有数字了，所以乘以1。</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; output(nums.size(),1);

        for(int i=1;i&lt;nums.size();i++)
        {
            output[i]=output[i-1]*nums[i-1];
        }

        int right=1;
        for(int i=nums.size()-1;i&gt;=0;i--)
        {
            output[i] *= right;
            right *= nums[i];
        }

        return output;
    }
};
</code></pre><h2 id="Same-Tree"><a href="#Same-Tree" class="headerlink" title="Same Tree"></a>Same Tree</h2><p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<p>这个题明显可以用递归的方法解决,不过要考虑两种特殊的情况,当都是空的时候是真的,当有一个空的时候是假的.</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p &amp;&amp; !q) return true;
        if(!p || !q) return false;
        return (p-&gt;val==q-&gt;val)&amp;&amp;(isSameTree(p-&gt;left,q-&gt;left))&amp;&amp;(isSameTree(p-&gt;right,q-&gt;right));
    }
};
</code></pre><h2 id="Excel-Sheet-Column-Title"><a href="#Excel-Sheet-Column-Title" class="headerlink" title="Excel Sheet Column Title"></a>Excel Sheet Column Title</h2><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<ul>
<li>1 -&gt; A</li>
<li>2 -&gt; B</li>
<li>3 -&gt; C</li>
<li>…</li>
<li>26 -&gt; Z</li>
<li>27 -&gt; AA</li>
<li>28 -&gt; AB </li>
</ul>
<p>注意当这个数能被26整除时,要-1防止多出现一个A</p>
<pre><code>class Solution {
public:
    string convertToTitle(int n) {
        string res;
        while(n&gt;0)
        {
            char ch = &apos;A&apos; + (n-1)%26;
            res.insert(res.begin(), ch);
            if(n%26==0) n=n-1;
            n /= 26;
        }

        return res;
    }
};
</code></pre><h2 id="Valid-Anagram"><a href="#Valid-Anagram" class="headerlink" title="Valid Anagram"></a>Valid Anagram</h2><p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>
<p>For example,<br>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p>
<pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        sort(s.begin(),s.end());
        sort(t.begin(),t.end());
        return s==t;
    }
};
</code></pre><h2 id="Fizz-Buzz"><a href="#Fizz-Buzz" class="headerlink" title="Fizz Buzz"></a>Fizz Buzz</h2><p>Write a program that outputs the string representation of numbers from 1 to n.</p>
<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>
<p>Example:</p>
<pre><code>n = 15,

Return:
[
    &quot;1&quot;,
    &quot;2&quot;,
    &quot;Fizz&quot;,
    &quot;4&quot;,
    &quot;Buzz&quot;,
    &quot;Fizz&quot;,
    &quot;7&quot;,
    &quot;8&quot;,
    &quot;Fizz&quot;,
    &quot;Buzz&quot;,
    &quot;11&quot;,
    &quot;Fizz&quot;,
    &quot;13&quot;,
    &quot;14&quot;,
    &quot;FizzBuzz&quot;
]
</code></pre><p>JS代码如下:</p>
<pre><code>/**
 * @param {number} n
 * @return {string[]}
 */
var fizzBuzz = function(n) {
    var arr = [];
    var str = &quot;&quot;;
    for(var i = 0; i &lt; n; i++) {
        str = &quot;&quot;;
        if((i+1)%3 === 0)  str += &quot;Fizz&quot;;
        if((i+1)%5 === 0)  str += &quot;Buzz&quot;;
        if(!str) str += i+1;
        arr.push(str);
    }
    return arr;

};
</code></pre><h2 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h2><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p>
<pre><code>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        // 返回的是最大子数组的和

        int n = nums.size();
        vector&lt;int&gt; sum(n,0);
        sum[0] = nums[0];
        int res = sum[0];
        for(int i=1; i&lt;n; i++) {
            sum[i] = max(nums[i], nums[i]+sum[i-1]);
            res = max(res, sum[i]);
        }

        return res;
    }
};
</code></pre><p>使用一个vector存储一个sum数组，sum[i] = max(nums[i]+sum[i-1], nums[i])， res是当前的res和sum[i]的比较，时间复杂度为O(n)</p>
<h2 id="Repeated-Substring-Pattern"><a href="#Repeated-Substring-Pattern" class="headerlink" title="Repeated Substring Pattern"></a>Repeated Substring Pattern</h2><p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.</p>
<p>Example 1:</p>
<pre><code>Input: &quot;abab&quot;
Output: True
Explanation: It&apos;s the substring &quot;ab&quot; twice.
</code></pre><p>Example 2:</p>
<pre><code>Input: &quot;aba&quot;
Output: False
</code></pre><p>Example 3:</p>
<pre><code>Input: &quot;abcabcabcabc&quot;
Output: True

Explanation: It&apos;s the substring &quot;abc&quot; four times.     (And the substring &quot;abcabc&quot; twice.)
</code></pre><p>代码实现：</p>
<pre><code>class Solution {
public:
    bool repeatedSubstringPattern(string str) {
        // 判断一个字符串能否被拆成重复的子字符串

        bool res = false;

        int n = str.size(); 

        for(int p=1;p&lt;=n/2;p++){ // 两个相同字符的间距
            int i;
            for(i=0; i&lt;n-p; i++) {
                res = true;
                if(str[i] != str[i+p]){
                    res = false;
                    break;
                }
            }
            if(res == true &amp;&amp; i%p == 0){
                res = true;
                break;
            }else res = false;
        }

        return res;
    }
};
</code></pre><p>间隔从1开始，判断相邻间隔的字符是否相同。</p>
<h2 id="Climbing-Stairs"><a href="#Climbing-Stairs" class="headerlink" title="Climbing Stairs"></a>Climbing Stairs</h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<pre><code>class Solution {
public:
    int climbStairs(int n) {
        // 一共需要走n步，每次可以走一步或者两步，返回的是一共可以有多少种方法走到山顶
        // 就是斐波那契数列
        if(n&lt;=3)return n;
        int a[2] = {2,3};
        for(int i=4; i&lt;=n; i++){
            int t = a[0]+a[1];
            a[0] = a[1];
            a[1] = t;
        }

        return a[1];
    }
};
</code></pre><p>要把实际问题转换成特殊的数学模型，这个算法就是转换成斐波那契数列。</p>
<h2 id="Hamming-Distance"><a href="#Hamming-Distance" class="headerlink" title="Hamming Distance"></a>Hamming Distance</h2><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Given two integers x and y, calculate the Hamming distance.</p>
<p>Note:<br>0 ≤ x, y &lt; 231.</p>
<p>Example:</p>
<pre><code>Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
</code></pre><p>The above arrows point to positions where the corresponding bits are different.</p>
<pre><code>class Solution {
public:
    int hammingDistance(int x, int y) {
        int cnt = 0;
        int t = x ^ y;
        while(t){
            if(t &amp; 1){
                cnt++;
            }
            t&gt;&gt;=1;
        }
        return cnt;
    }
};
</code></pre><p>这个算法较为简单，利用异或性质可以简单得出结果。</p>
<h2 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a>Path Sum</h2><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
</code></pre><p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        // 二叉树类型的算法基本都会利用递归
        if(root == NULL)return false;
        else if(root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)return true;
        else{
            return hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);
        }

    }
};
</code></pre><h2 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a>Path Sum II</h2><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
</code></pre><p>return</p>
<pre><code>[
   [5,4,11,2],
   [5,8,4,5]
]


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; v;
        addVec(root, sum, v, res);
        return res;
    }

    void addVec(TreeNode* root, int sum, vector&lt;int&gt; &amp;pre, vector&lt;vector&lt;int&gt;&gt; &amp;res){
        if(root == NULL) return;
        vector&lt;int&gt; v;
        v.assign(pre.begin(), pre.end());
        v.push_back(root-&gt;val);
        if(root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL){
            res.push_back(v);
            return;
        }

        addVec(root-&gt;left, sum - root-&gt;val, v, res);
        addVec(root-&gt;right, sum - root-&gt;val, v, res);
    }
};
</code></pre><p>还是利用递归，但是在辅助函数中，每次要用一个新的数组v来存储数据，不要在传递进来的引用数组上操作。</p>
<h2 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h2><p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<pre><code>class Solution {
public:
    bool isUgly(int num) {

        if(num == 1)return true;
        if(num &lt;= 0)return false;

        while(num % 2 == 0) num /= 2;
        while(num % 3 == 0) num /= 3;
        while(num % 5 == 0) num /= 5;

        return num == 1;

    }
};
</code></pre><h2 id="Ugly-Number-II"><a href="#Ugly-Number-II" class="headerlink" title="Ugly Number II"></a>Ugly Number II</h2><p>Write a program to find the n-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</p>
<p>Note that 1 is typically treated as an ugly number, and n does not exceed 1690.</p>
<pre><code>class Solution {
public:
    int nthUglyNumber(int n) {
        int i=0, j=0, k=0;
        vector&lt;int&gt; res(1,1);

        while(res.size() &lt; n){
            int next = min(min(res[i]*2, res[j]*3), res[k]*5);
            if(next == res[i]*2) i++;
            if(next == res[j]*3) j++;
            if(next == res[k]*5) k++;
            res.push_back(next);
        }

        return res.back();
    }
};
</code></pre><p>在计算next时，判断next==res[x]*y时，不是if，else if，else，而是三个if，因为有可能两项相当，此时相等的两项都要++，否则数组中会有重复值出现。</p>
<h2 id="Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Search Tree"></a>Lowest Common Ancestor of a Binary Search Tree</h2><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<pre><code>     _______6______
    /              \
 ___2__          ___8__
/      \        /      \
0      _4       7       9
      /  \
      3   5
</code></pre><p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while(root) {

            if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val){
                root = root-&gt;left;
                continue;
            }
            if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val){
                root = root-&gt;right;
                continue;
            }

            return root;

        }
    }
};
</code></pre><p>给定的二叉树是一个平衡二叉树，要注意BST的相关性质。</p>
<p>## </p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // 返回的链表也应当是排好序的
        if(l1 == NULL &amp;&amp; l2 == NULL)return NULL;
        if(l1 == NULL) return l2;
        if(l2 == NULL) return l1;

        ListNode *head = NULL;
        ListNode *tail = NULL;
        while(l1 != NULL &amp;&amp; l2 != NULL ){
            ListNode *node = NULL;
            if(l2-&gt;val &lt; l1-&gt;val){
                node = l2;
                l2 = l2-&gt;next;
            }else {
                node = l1;
                l1 = l1-&gt;next;
            }
            if(head == NULL){ // 第一项
                head = tail = node;
            }else {
                tail-&gt;next = node;
                tail = tail-&gt;next;
            }
        }

        ListNode *rest = l1 ? l1 : l2;

        if(rest){
            tail-&gt;next = rest;
        }

        return head;
    }
};
</code></pre><p>类似于归并排序，要注意实现过程中的细节。</p>
<h2 id="Binary-Tree-Level-Order-Traversal-II"><a href="#Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="Binary Tree Level Order Traversal II"></a>Binary Tree Level Order Traversal II</h2><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>return its bottom-up level order traversal as:</p>
<pre><code>[
  [15,7],
  [9,20],
  [3]
]
</code></pre><p>代码实现：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
        // 层序遍历一般会用到队列
        vector&lt;vector&lt;int&gt;&gt; res; // 最终存储的数组
        queue&lt;TreeNode *&gt; q;
        if(root != NULL) q.push(root);
        while(q.size()){
            vector&lt;int&gt; level;
            int n = q.size();
            for(int i=0; i&lt;n; i++){ // 这里的循环条件不能直接写i&lt;q.size()，因为每次for循环完这个值会变化，要固定为n
                TreeNode *curr = q.front();
                q.pop();
                level.push_back(curr-&gt;val);
                if(curr-&gt;left) q.push(curr-&gt;left);
                if(curr-&gt;right) q.push(curr-&gt;right);
            }
            res.push_back(level);
        }
        reverse(res.begin(),res.end()); // 翻转整个数组
        return res;
    }
};
</code></pre><h2 id="Binary-Tree-Inorder-Traversal"><a href="#Binary-Tree-Inorder-Traversal" class="headerlink" title="Binary Tree Inorder Traversal"></a>Binary Tree Inorder Traversal</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree [1,null,2,3],</p>
<pre><code>1
 \
  2
 /
3
</code></pre><p>return [1,3,2].</p>
<p>递归实现：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        // 中序遍历，会用到递归(也可以不利用递归实现，需要用到栈);
        vector&lt;int&gt; res;
        inOrder(root, res);

        return res;

    }

    void inOrder(TreeNode* root, vector&lt;int&gt; &amp;vec) {
        if(root != NULL){
            inOrder(root-&gt;left, vec);
            vec.push_back(root-&gt;val);
            inOrder(root-&gt;right, vec);
        }

    }
};
</code></pre><p>非递归实现：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        // 非递归实现，需要用到栈辅助
        stack&lt;TreeNode *&gt; s;
        vector&lt;int&gt; res;
        while(s.size() || root != NULL) {
            if(root != NULL) {
                s.push(root);
                root = root-&gt;left;
            }else {
                if(s.size()){
                    root = s.top();
                    s.pop();
                    res.push_back(root-&gt;val);
                    root = root-&gt;right;
                }
            }
        }

        return res;
    }
};
</code></pre><h2 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<pre><code>class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        // 如果选了一个就不能选相邻的两个，求最大子数组和
        int n = nums.size();
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        vector&lt;int&gt; sum(n,0);
        sum[0] = nums[0];
        sum[1] = max(nums[0], nums[1]);
        for(int i=2; i&lt;n; i++) {
            sum[i] = max(sum[i-1], sum[i-2]+nums[i]);
        }

        return sum[n-1];
    }
};
</code></pre><p>更为简单的实现：</p>
<pre><code>class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        // 类似于斐波那契数列
        int n1 = 0, n2 = 0;
        for(int i = 0; i &lt; nums.size(); i++) {
            int curr = max(n1, n2 + nums[i]);
            n2 = n1;
            n1 = curr;
        }

        return n1;
    }
};
</code></pre><h2 id="House-Robber-II"><a href="#House-Robber-II" class="headerlink" title="House Robber II"></a>House Robber II</h2><p>Note: This is an extension of House Robber.</p>
<p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<pre><code>class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        int m1 = helper(nums, 0, n-1);
        int m2 = helper(nums, 1, n);
        return max(m1,m2);
    }

    int helper(vector&lt;int&gt;&amp; nums, int start, int end) {
        // 由于是一个环，可以判断两个数组从nums[0,....,n-2]或者[1,.....,n-1];
        int n1 = 0, n2 = 0;

        for(int i=start; i&lt;end; i++) {
            int curr = max(n1, n2+nums[i]);
            n2 = n1;
            n1 = curr;
        }

        return n1;
    }
};
</code></pre><h2 id="Number-Complement"><a href="#Number-Complement" class="headerlink" title="Number Complement"></a>Number Complement</h2><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p>Note:</p>
<ol>
<li>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li>
<li>You could assume no leading zero bit in the integer’s binary representation.</li>
</ol>
<p>Example 1:</p>
<pre><code>Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
</code></pre><p>Example 2:</p>
<pre><code>Input: 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.

class Solution {
public:
    int findComplement(int num) {
        int a[32] = {0};
        int n = 0;
        int res = 0;
        for(int i=0; i&lt;32&amp;&amp;num!=0; i++){
            a[i] = num%2;
            num /= 2;
            n++;
        }

        for(int i=0; i&lt;n; i++){
            a[i] = !a[i];
        }

        for(int i=0; i&lt;n; i++){
            res = res + a[i]*pow(2,i);
        }
        return res;
    }
};

利用一个数组保存每位，取反后再算成结果。
</code></pre><h2 id="Max-Consecutive-Ones"><a href="#Max-Consecutive-Ones" class="headerlink" title="Max Consecutive Ones"></a>Max Consecutive Ones</h2><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p>Example 1:</p>
<pre><code>Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.
</code></pre><p>Note:</p>
<p>The input array will only contain 0 and 1.</p>
<p>The length of input array is a positive integer and will not exceed 10,000</p>
<pre><code>class Solution {
public:
    int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) {
        int res = 0;
        int maxT = 0;
        for(int i=0; i&lt;nums.size(); i++){
            if(nums[i]==1){
                maxT++;
                res = max(res, maxT);
            }else{
                maxT = 0;
            }
        }
        return res;
    }
};
</code></pre><h2 id="Island-Perimeter"><a href="#Island-Perimeter" class="headerlink" title="Island Perimeter"></a>Island Perimeter</h2><p>ou are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p>
<p>Example:</p>
<pre><code>[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

Answer: 16
Explanation: The perimeter is the 16 yellow stripes in the image below:
</code></pre><p><img src="https://leetcode.com/static/images/problemset/island.png" alt=""></p>
<pre><code>class Solution {
public:
    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int islandNum = 0, linkNum = 0;
        for(int i=0; i&lt;grid.size(); i++){
            for(int j=0; j&lt;grid[i].size(); j++){
                if(grid[i][j]==1){
                    islandNum ++;
                }
                if(j&gt;=1 &amp;&amp; grid[i][j]==1 &amp;&amp; grid[i][j-1]==1){
                    linkNum ++;
                }
                if(i&gt;=1 &amp;&amp; grid[i][j]==1 &amp;&amp; grid[i-1][j]==1){
                    linkNum ++;
                }
            }
        }

        return islandNum * 4 - linkNum * 2;
    }
};
</code></pre><p>先找到规律再写算法。</p>
<h2 id="Find-All-Numbers-Disappeared-in-an-Array"><a href="#Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="Find All Numbers Disappeared in an Array"></a>Find All Numbers Disappeared in an Array</h2><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<p>Example:</p>
<pre><code>Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
</code></pre><p>代码实现：</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;bool&gt; hash(n, false);

        for(int i=0; i&lt;n; i++){
            hash[nums[i]-1] = true;
        }

        vector&lt;int&gt; res;
        for(int i=0; i&lt;n; i++){
            if(hash[i]==0){
                res.push_back(i+1);
            }
        }

        return res;
    }
};
</code></pre><h2 id="Construct-the-Rectangle"><a href="#Construct-the-Rectangle" class="headerlink" title="Construct the Rectangle"></a>Construct the Rectangle</h2><p>For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p>
<pre><code>1. The area of the rectangular web page you designed must equal to the given target area.

2. The width W should not be larger than the length L, which means L &gt;= W.

3. The difference between length L and width W should be as small as possible.
</code></pre><p>You need to output the length L and the width W of the web page you designed in sequence.<br>Example:</p>
<pre><code>Input: 4
Output: [2, 2]
Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. 
But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.
</code></pre><p>Note:</p>
<pre><code>* The given area won&apos;t exceed 10,000,000 and is a positive integer
* The web page&apos;s width and length you designed must be positive integers.
</code></pre><p>代码实现：</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; constructRectangle(int area) {
        int w,l;
        vector&lt;int&gt; res;
        for(int i=sqrt(area); i&lt;=area; i++){
            l = i;
            w = area / l;

            if(l*w == area &amp;&amp; l&gt;=w){
                res.push_back(l);
                res.push_back(w);
                break;
            }
        }

        return res;
    }
};
</code></pre><h2 id="Search-a-2D-Matrix"><a href="#Search-a-2D-Matrix" class="headerlink" title="Search a 2D Matrix"></a>Search a 2D Matrix</h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<p>Integers in each row are sorted from left to right.<br>The first integer of each row is greater than the last integer of the previous row.<br>For example,</p>
<p>Consider the following matrix:</p>
<pre><code>[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
</code></pre><p>Given target = 3, return true.</p>
<pre><code>class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        if(matrix.size()==0)return false;
        int rows = matrix.size(), cols = matrix[0].size();

        int row = 0, col = cols - 1;
        bool res = false;
        while(row&lt;rows &amp;&amp; col&gt;=0){
            if(matrix[row][col] == target){
                res = true;
                break;
            }
            else if(matrix[row][col] &lt; target){
                row++;
            }else{
                col--;
            }
        }

        return res;
    }
};
</code></pre><p>从右上角或者左下角开始找都可以。</p>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<pre><code>class Solution {
public:
    void replaceSpace(char *str,int length) {
        if(str == NULL) return;
        int originalLength = 0, spaceNum = 0;
        while(str[originalLength] != &apos;\0&apos;){
            if(str[originalLength] == &apos; &apos;){
                spaceNum++;
            }
            originalLength++;
        }
        int newLength = originalLength + spaceNum * 2;
        int p2 = newLength;
        int p1 = originalLength;

        while(p1 &lt; p2 &amp;&amp; p1&gt;=0) {
            if(str[p1] == &apos; &apos;){
                str[p2--] = &apos;0&apos;;
                str[p2--] = &apos;2&apos;;
                str[p2--] = &apos;%&apos;;
            }
            else {
                str[p2--] = str[p1];
            }
            p1--;
        }
    }
};
</code></pre><p>如果从前开始时间复杂度为O(n^2)，从后开始每项只需要移动一次，时间复杂度为O(n)。</p>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<pre><code>/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) {
        if(pre.size()==0 || vin.size()==0)return NULL;
        int l = pre.size()-1;
        return helper(pre, vin, 0, l, 0, l);
    }

    TreeNode* helper(vector&lt;int&gt; &amp;pre,vector&lt;int&gt; &amp;vin, int preStart, int preEnd, int vinStart, int vinEnd){
        int rootvalue = pre[preStart];
        TreeNode *node = new TreeNode(rootvalue);

        if(preStart == preEnd &amp;&amp; vinStart == vinEnd){
            return node;
        }
        int i; // 前序遍历的第一个在中序遍历中是第几个
           for(i=vinStart; i&lt;vinEnd; i++){
            if(vin[i] == rootvalue){
                break;
            }
        }
        int leftLength = i-vinStart;
        if(leftLength&gt;0){
            node-&gt;left = helper(pre, vin, preStart+1, preStart+leftLength, vinStart, i-1);
        }
        if(leftLength&lt;preEnd-preStart){
            node-&gt;right = helper(pre, vin, preStart+leftLength+1, preEnd, i+1, vinEnd);
        }

        return node;
    }
};
</code></pre><h2 id="Implement-Queue-using-Stacks"><a href="#Implement-Queue-using-Stacks" class="headerlink" title="Implement Queue using Stacks"></a>Implement Queue using Stacks</h2><p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) – Push element x to the back of queue.</li>
<li>pop() – Removes the element from in front of queue.</li>
<li>peek() – Get the front element.</li>
<li>empty() – Return whether the queue is empty.</li>
</ul>
<p>Notes:</p>
<ul>
<li>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.</li>
<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>
<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>
</ul>
<p>代码实现：</p>
<pre><code>class MyQueue {
private:
    stack&lt;int&gt; s1, s2;
    void transfer(stack&lt;int&gt; &amp;s1, stack&lt;int&gt; &amp;s2){
         while(!s1.empty()){
            s2.push(s1.top());
            s1.pop();
        }
    }

public:
    /** Initialize your data structure here. */
    MyQueue() {
    }

    /** Push element x to the back of queue. */
    void push(int x) {
        s1.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    int pop() {
       transfer(s1, s2);
       int res = s2.top();
       s2.pop();
       transfer(s2, s1);
       return res;
    }

    /** Get the front element. */
    int peek() {
        transfer(s1, s2);
        int res = s2.top();
        transfer(s2,s1);
        return res;
    }

    /** Returns whether the queue is empty. */
    bool empty() {
        return s1.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * bool param_4 = obj.empty();
 */
</code></pre><h2 id="Implement-Stack-using-Queues"><a href="#Implement-Stack-using-Queues" class="headerlink" title="Implement Stack using Queues"></a>Implement Stack using Queues</h2><p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>empty() – Return whether the stack is empty.</li>
</ul>
<p>代码实现：</p>
<pre><code>class MyStack {
private:
    queue&lt;int&gt; q1;
public:
    /** Initialize your data structure here. */
    MyStack() {

    }

    /** Push element x onto stack. */
    void push(int x) {
        q1.push(x);
    }

    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        if(!empty()){
            int length = q1.size();
            while(length-- &gt; 1){
                q1.push(q1.front());
                q1.pop();
            }

            int res = q1.front();
            q1.pop();
            return res;
        }
    }

    /** Get the top element. */
    int top() {
        int res = q1.back();
        return res;
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return q1.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * bool param_4 = obj.empty();
 */
</code></pre><p>由于有一个queue.back()方法，所以使用一个队列就可以模拟栈，在pop方法中，通过不断地将队头弹出插入到队尾，直到要弹出的元素从队尾移到队头，弹出就可以了。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>挖坑填数法：<br><a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="external">参考资料</a></p>
<pre><code>class QuickSort {
public:
    int* quickSort(int* A, int n) {
        // write code here
        quicksort(A, 0, n-1);
        return A;
    }
    void quicksort(int *A, int start, int end){
        if(start &lt; end){
            int index = Partition(A, start, end);
            quicksort(A, start, index-1);
            quicksort(A, index+1, end);
        }
    }

    int Partition(int *A, int start, int end){
        int i = start, j = end;
        int key = A[start]; //挖坑填数
        while(i &lt; j){
            while(i &lt; j &amp;&amp; A[j] &gt; key) j--;
            if(i&lt;j){
                A[i] = A[j];
                i++;
            }
            while(i &lt; j &amp;&amp; A[i] &lt; key) i++;
            if(i&lt;j){
                A[j] = A[i];
                j--;
            }
        }

        A[i] = key;
        return i;
    }

};
</code></pre><h2 id="Find-Minimum-in-Rotated-Sorted-Array"><a href="#Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Find Minimum in Rotated Sorted Array"></a>Find Minimum in Rotated Sorted Array</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <strong>0 1 2 4 5 6 7</strong> might become <strong>4 5 6 7 0 1 2</strong>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<pre><code>class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        int low = 0, high = nums.size()-1;
        int indexMid = low;
        while(nums[low] &gt;= nums[high]){
            if(high - low == 1){
                indexMid = high;
                break;
            }
            indexMid = (low+high) / 2;

            if(nums[low] == nums[high] &amp;&amp; nums[low] == nums[indexMid] &amp;&amp; nums[high] == nums[indexMid]){
                return MinInOrder(nums, low, high);
            }

            if(nums[low] &lt;= nums[indexMid]) low = indexMid;
            else if(nums[indexMid] &lt;= nums[high]) high = indexMid;
        }
        return nums[indexMid];
    }

    int MinInOrder(vector&lt;int&gt;&amp; nums, int low, int high){
        int minN = nums[low];
        for(int i = low+1; i&lt;=high; i++){
            minN = min(minN, nums[i]);
        }
        return minN;
    }
};
</code></pre><h2 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<pre><code>class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        if(nums.size()==0)return -1;
        if(nums.size()==1)return nums[0] == target ? 0:-1;
        int low = 0, high = nums.size()-1;
        while(low&lt;=high){
            if(nums[low]&lt;=nums[high] &amp;&amp; (target&lt;nums[low] || target&gt;nums[high])){
                return -1;
            }
            int mid = (low+high)/2;
            if(nums[mid] == target) return mid;
            if(nums[low] &lt; nums[mid] &amp;&amp; target&gt;=nums[low] &amp;&amp; target&lt; nums[mid]){
                high = mid-1;
                continue;
            }
            if(nums[mid] &lt; nums[high] &amp;&amp; target &lt;=nums[high] &amp;&amp; target &gt;nums[mid]){
                low = mid+1;
                continue;
            }
            if(nums[low] &gt; nums[mid]){
                high = mid-1;
                continue;
            }
            if(nums[high] &lt; nums[mid]){
                low = mid+1;
                continue;
            }
        }

        return -1;
    }
};

还是采用分治法的思想，将数组分成两部分，一部分是排好序的，一部分是没排好序的，检查target是否在排好序的数组里面，如果是的话，按经典二分法查找，如果不是继续划分数组。
</code></pre><h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<pre><code>class Solution {
public:
     int  NumberOf1(int n) {
         int count = 0;
         while(n){
             count++;
             n = n&amp;(n-1);
         }

         return count;
     }
};
</code></pre><p>注意给出的数字n可能为负数，所以不要写那种会引起死循环的算法。</p>
<h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<pre><code>class Solution {
public:
    double Power(double base, int exponent) {
         if(exponent == 0)return 1;

        int n = abs(exponent);
        double res = 1.0;

         // for(int i=0; i&lt;n; i++){
         // res = res*base;
         // }
        while(n){
            if(n&amp;1){
                res *= base;
            }
            base *= base;
            n &gt;&gt;= 1;
        }

        return exponent&gt;0? res: 1/res;
    }

};
</code></pre><p>要注意给定的exponent为0或者负数的情况，为0直接返回1，为负数，返回exponent绝对值结果的倒数。</p>
<p>在正数求幂的过程中，可以用上面的方法提高性能。</p>
<h2 id="Maximum-Subarray-1"><a href="#Maximum-Subarray-1" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h2><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p>
<pre><code>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        // 返回的是最大子数组的和

        int n = nums.size();
        vector&lt;int&gt; sum(n,0);
        sum[0] = nums[0];
        int res = sum[0];
        for(int i=1; i&lt;n; i++) {
            sum[i] = max(nums[i], nums[i]+sum[i-1]);
            res = max(res, sum[i]);
        }

        return res;
    }
};
</code></pre><p>利用动态规划，f(i)是以i为结尾的子数组的最大和，结果就是max(f(i))。</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>对于一个有序数组，我们通常采用二分查找的方式来定位某一元素，请编写二分查找的算法，在数组中查找指定元素。</p>
<p>给定一个整数数组A及它的大小n，同时给定要查找的元素val，请返回它在数组中的位置(从0开始)，若不存在该元素，返回-1。<strong>若该元素出现多次，请返回第一次出现的位置</strong>。</p>
<pre><code>class BinarySearch {
public:
    int getPos(vector&lt;int&gt; A, int n, int val) {
        // write code here
        int low = 0, high = n-1;
        while(low&lt;high){
            int mid = (low + high) / 2;
            if(A[mid] &lt; val) {
                low = mid + 1;
            } else if(A[mid] &gt; val) {
                high = mid - 1;
            }else {
                high = mid;
            }
        }
        if(A[low] == val)return low;
        else return -1;

    }
};
</code></pre><p>与经典的二分查找不同，该算法要求返回元素第一次出现的位置，所以稍有区别。</p>
<h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>如果不需要保证相对位置不变，只需要奇数在前，偶数在后，可以用下面算法实现：</p>
<pre><code>class Solution {
public:
    void reOrderArray(vector&lt;int&gt; &amp;array) {
        int n = array.size();
        int p1=0, p2 = n-1;

        while(p2-p1&gt;1){
            while(array[p1]&amp;1){ //是偶数
                p1++;
            }
            while(!(array[p2]&amp;1)){
                p2--;
            }
            swap(array[p1], array[p2]);
        }

    }
};
</code></pre><h2 id="Odd-Even-Linked-List"><a href="#Odd-Even-Linked-List" class="headerlink" title="Odd Even Linked List"></a>Odd Even Linked List</h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p>Example:</p>
<pre><code>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,
return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.
</code></pre><p>Note:</p>
<p>The relative order inside both the even and odd groups should remain as it was in the input. </p>
<p>The first node is considered odd, the second node even and so on …</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(!head || !head-&gt;next) return head;
        ListNode *odd = head;
        ListNode *even = head-&gt;next;
        ListNode *evenHead = even;
        while(odd-&gt;next &amp;&amp; even-&gt;next){
            odd-&gt;next = even-&gt;next;
            odd = odd-&gt;next;
            even-&gt;next = odd-&gt;next;
            even = even-&gt;next;
        }

        odd-&gt;next = evenHead;
        return head;
    }
};
</code></pre><h2 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<pre><code>/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
            val(x), next(NULL) {
    }
};*/
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        if(!pListHead)return NULL;
        ListNode *p1 = pListHead;
        ListNode *p2 = pListHead;
        for(int i=0; i&lt;k-1; i++){
            if(p1-&gt;next){
                p1 = p1-&gt;next;
            }
            else {
                return NULL;
            }
        }

        while(p1-&gt;next){
            p1 = p1-&gt;next;
            p2 = p2-&gt;next;
        }

        return p2;
    }
};
</code></pre><p>定义两个指针，让第一个指针先走k-1步，然后两个指针同时移动，当第一个指针移到最后时，第二个指针指到倒数第k个结点，时间复杂度O(n).</p>
<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>要判断的是 <strong>是不是子结构</strong> 而不是 <strong>是不是子树</strong></p>
<pre><code>/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        bool res = false;
        while(pRoot1 &amp;&amp; pRoot2){
            if(pRoot1-&gt;val == pRoot2-&gt;val){
                res = DoesTree1HasTree2(pRoot1, pRoot2);
            }
            if(!res){
                res = HasSubtree(pRoot1-&gt;left, pRoot2);
            }
            if(!res){
                res = HasSubtree(pRoot1-&gt;right, pRoot2);
            }
        }
        return res;
    }

    bool DoesTree1HasTree2(TreeNode* pRoot1, TreeNode* pRoot2){
        if(pRoot1 == NULL &amp;&amp; pRoot2 != NULL) return false;
        if(pRoot2 == NULL) return true;
        if(pRoot1-&gt;val != pRoot2-&gt;val)return false;
        return DoesTree1HasTree2(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; DoesTree1HasTree2(pRoot1-&gt;right, pRoot2-&gt;right);
    }
};
</code></pre><p>两个函数都是递归，要注意第二个函数的返回条件，当pRoot2 == NULL时，证明子结构已经到了叶节点，上面所有结点判断都是true，所以返回true。</p>
<h2 id="整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="整数中1出现的次数（从1到n整数中1出现的次数）"></a>整数中1出现的次数（从1到n整数中1出现的次数）</h2><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<pre><code>class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n)
    {
        int cnt = 0;
        int factor = 1;
        int lowerNum = 0;
        int currNum = 0;
        int higherNum = 0;

        while(n/factor != 0){
            lowerNum = n - (n/factor) * factor;
            currNum = (n/factor) % 10;
            higherNum = n/(factor*10);

            switch(currNum){
                case 0:
                    cnt+=higherNum * factor;
                    break;
                case 1:
                    cnt+=higherNum*factor + lowerNum+1;
                    break;
                default:
                    cnt+=(higherNum+1) * factor;

            }

            factor *= 10;
        }

        return cnt;
    }


};
</code></pre><p>编程之美P132上有解析。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/26/Markdown入门/" rel="next" title="Markdown基本介绍">
                <i class="fa fa-chevron-left"></i> Markdown基本介绍
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/10/Hexo-NexT主题/" rel="prev" title="Hexo-NexT主题">
                Hexo-NexT主题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/06/27/LeetCode题解/"
           data-title="LeetCode题解" data-url="http://yoursite.com/2016/06/27/LeetCode题解/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ww4.sinaimg.cn/mw690/719c39c3gw1f4jhs5r30dj206o06o74c.jpg"
               alt="李普阳" />
          <p class="site-author-name" itemprop="name">李普阳</p>
          <p class="site-description motion-element" itemprop="description">一个人的命运啊，当然要靠自我奋斗。但是，也要考虑到历史的行程。（手动滑稽</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/p/1005053917294273/home?from=page_100505&mod=TAB&is_all=1#place" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Reverse-String"><span class="nav-number">1.</span> <span class="nav-text">Reverse String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nim-Game"><span class="nav-number">2.</span> <span class="nav-text">Nim Game</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Single-Number"><span class="nav-number">3.</span> <span class="nav-text">Single Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Add-Digits"><span class="nav-number">4.</span> <span class="nav-text">Add Digits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maximum-Depth-of-Binary-Tree"><span class="nav-number">5.</span> <span class="nav-text">Maximum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reverse-Linked-List"><span class="nav-number">6.</span> <span class="nav-text">Reverse Linked List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Counting-Bits"><span class="nav-number">7.</span> <span class="nav-text">Counting Bits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Invert-Binary-Tree"><span class="nav-number">8.</span> <span class="nav-text">Invert Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sum-of-Two-Integers"><span class="nav-number">9.</span> <span class="nav-text">Sum of Two Integers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Single-Number-III"><span class="nav-number">10.</span> <span class="nav-text">Single Number III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Move-Zeroes"><span class="nav-number">11.</span> <span class="nav-text">Move Zeroes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Intersection-of-Two-Arrays"><span class="nav-number">12.</span> <span class="nav-text">Intersection of Two Arrays</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Delete-Node-in-a-Linked-List"><span class="nav-number">13.</span> <span class="nav-text">Delete Node in a Linked List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Product-of-Array-Except-Self"><span class="nav-number">14.</span> <span class="nav-text">Product of Array Except Self</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Same-Tree"><span class="nav-number">15.</span> <span class="nav-text">Same Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Excel-Sheet-Column-Title"><span class="nav-number">16.</span> <span class="nav-text">Excel Sheet Column Title</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Valid-Anagram"><span class="nav-number">17.</span> <span class="nav-text">Valid Anagram</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fizz-Buzz"><span class="nav-number">18.</span> <span class="nav-text">Fizz Buzz</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maximum-Subarray"><span class="nav-number">19.</span> <span class="nav-text">Maximum Subarray</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Repeated-Substring-Pattern"><span class="nav-number">20.</span> <span class="nav-text">Repeated Substring Pattern</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Climbing-Stairs"><span class="nav-number">21.</span> <span class="nav-text">Climbing Stairs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hamming-Distance"><span class="nav-number">22.</span> <span class="nav-text">Hamming Distance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Path-Sum"><span class="nav-number">23.</span> <span class="nav-text">Path Sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Path-Sum-II"><span class="nav-number">24.</span> <span class="nav-text">Path Sum II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ugly-Number"><span class="nav-number">25.</span> <span class="nav-text">Ugly Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ugly-Number-II"><span class="nav-number">26.</span> <span class="nav-text">Ugly Number II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="nav-number">27.</span> <span class="nav-text">Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Tree-Level-Order-Traversal-II"><span class="nav-number">28.</span> <span class="nav-text">Binary Tree Level Order Traversal II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Tree-Inorder-Traversal"><span class="nav-number">29.</span> <span class="nav-text">Binary Tree Inorder Traversal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-Robber"><span class="nav-number">30.</span> <span class="nav-text">House Robber</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-Robber-II"><span class="nav-number">31.</span> <span class="nav-text">House Robber II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number-Complement"><span class="nav-number">32.</span> <span class="nav-text">Number Complement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Max-Consecutive-Ones"><span class="nav-number">33.</span> <span class="nav-text">Max Consecutive Ones</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Island-Perimeter"><span class="nav-number">34.</span> <span class="nav-text">Island Perimeter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Find-All-Numbers-Disappeared-in-an-Array"><span class="nav-number">35.</span> <span class="nav-text">Find All Numbers Disappeared in an Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Construct-the-Rectangle"><span class="nav-number">36.</span> <span class="nav-text">Construct the Rectangle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Search-a-2D-Matrix"><span class="nav-number">37.</span> <span class="nav-text">Search a 2D Matrix</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#替换空格"><span class="nav-number">38.</span> <span class="nav-text">替换空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重建二叉树"><span class="nav-number">39.</span> <span class="nav-text">重建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implement-Queue-using-Stacks"><span class="nav-number">40.</span> <span class="nav-text">Implement Queue using Stacks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implement-Stack-using-Queues"><span class="nav-number">41.</span> <span class="nav-text">Implement Stack using Queues</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序"><span class="nav-number">42.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Find-Minimum-in-Rotated-Sorted-Array"><span class="nav-number">43.</span> <span class="nav-text">Find Minimum in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Search-in-Rotated-Sorted-Array"><span class="nav-number">44.</span> <span class="nav-text">Search in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制中1的个数"><span class="nav-number">45.</span> <span class="nav-text">二进制中1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值的整数次方"><span class="nav-number">46.</span> <span class="nav-text">数值的整数次方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maximum-Subarray-1"><span class="nav-number">47.</span> <span class="nav-text">Maximum Subarray</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分查找"><span class="nav-number">48.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调整数组顺序使奇数位于偶数前面"><span class="nav-number">49.</span> <span class="nav-text">调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Odd-Even-Linked-List"><span class="nav-number">50.</span> <span class="nav-text">Odd Even Linked List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表中倒数第k个结点"><span class="nav-number">51.</span> <span class="nav-text">链表中倒数第k个结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树的子结构"><span class="nav-number">52.</span> <span class="nav-text">树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整数中1出现的次数（从1到n整数中1出现的次数）"><span class="nav-number">53.</span> <span class="nav-text">整数中1出现的次数（从1到n整数中1出现的次数）</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李普阳</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>
        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"pangzili"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  

</body>
</html>
