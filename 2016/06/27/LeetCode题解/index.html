<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="开了个大坑，慢慢来，顺序是按Acceptance从大到小排序，等我全部做完以后再按类型分类，一天做两三个估计得三四个月（233">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode题解">
<meta property="og:url" content="http://yoursite.com/2016/06/27/LeetCode题解/index.html">
<meta property="og:site_name" content="胖子李">
<meta property="og:description" content="开了个大坑，慢慢来，顺序是按Acceptance从大到小排序，等我全部做完以后再按类型分类，一天做两三个估计得三四个月（233">
<meta property="og:updated_time" content="2016-11-08T11:39:11.556Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode题解">
<meta name="twitter:description" content="开了个大坑，慢慢来，顺序是按Acceptance从大到小排序，等我全部做完以后再按类型分类，一天做两三个估计得三四个月（233">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/06/27/LeetCode题解/"/>

  <title> LeetCode题解 | 胖子李 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?0e848dc3bf106cbfb59929b6254ac0d0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">胖子李</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">一个人的命运啊，当然要靠自我奋斗。但是，也要考虑到历史的行程。（手动滑稽</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                LeetCode题解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-27T00:00:00+08:00" content="2016-06-27">
              2016-06-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/27/LeetCode题解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/27/LeetCode题解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
		  
          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>开了个大坑，慢慢来，顺序是按Acceptance从大到小排序，等我全部做完以后再按类型分类，一天做两三个估计得三四个月（233</p>
<a id="more"></a>
<h2 id="Reverse-String"><a href="#Reverse-String" class="headerlink" title="Reverse String"></a>Reverse String</h2><p>Write a function that takes a string as input and returns the string reversed.</p>
<p>Example:<br>Given s = “hello”, return “olleh”.</p>
<pre><code>class Solution {
public:
    string reverseString(string s) {
        if(s == &quot;&quot;)return &quot;&quot;;
        char temp;
        int len = s.length();
        for(int i=0;i&lt;len/2;i++)
        {
            temp = s[i];
            s[i]=s[s.length()-i-1];
            s[s.length()-i-1] = temp;
        }
        return s;     
    }
};
</code></pre><h2 id="Nim-Game"><a href="#Nim-Game" class="headerlink" title="Nim Game"></a>Nim Game</h2><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>可以拿1-3个石子，拿到最后一个石子的人获胜，假设你是第一个拿石子的人。</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>
<p>分析：</p>
<blockquote>
<ul>
<li>0 块石子 - false</li>
<li>1 块石子 - true</li>
<li>2 块石子 - true</li>
<li>3 块石子 - true</li>
<li>4 块石子 - false</li>
<li>5 块石子 - true</li>
<li>6 块石子 - true</li>
<li>7 块石子 - true</li>
<li>8 块石子 - false</li>
</ul>
</blockquote>
<p>发现，当是4块时，这时要拿石子的人不管拿1-3中的几块，都会失败</p>
<p>而总数是5块时，可以拿1块让总数变成4块，总数是6块时，可以拿2块让总数变成4块…..</p>
<p>以此类推，发现当4的倍数时失败，其余情况成功。</p>
<pre><code>class Solution {
public:
    bool canWinNim(int n) {
        if(n%4 == 0)
        return false;
        else 
        return true;
    }
};
</code></pre><h2 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h2><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>给定一个整形数组，只有一个数字出现了一次，其余的都出现了两次，找到这个只出现了一次的数组。</p>
<p>这个题第一次看到的时候，我是这样做的：</p>
<pre><code>class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {

        int temp;

        for (int i=0;i&lt;nums.size();i++)
        {
            temp = nums[i];
            bool flag = false;
            for(int j=0;j&lt;nums.size();j++)
            {
                if(j==i)continue;
                if(temp == nums[j])
                flag = true;
            }

            if(flag == false)
                break;

        }
            return temp;
    }
};
</code></pre><p>时间复杂度为O(n^2)，结果是：Time Limit Exceeded</p>
<p>后来发现有两个公式：</p>
<blockquote>
<ul>
<li>a ⊕ a = 0</li>
<li>a ⊕ 0 = a</li>
</ul>
</blockquote>
<p>可以写出一段特别简单的代码：</p>
<pre><code>class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int temp=0;
        for(int i=0;i&lt;nums.size();i++)
        {
            temp = temp xor nums[i];
        }
        return temp;  
    }
};
</code></pre><p>时间复杂度为O(n)。</p>
<h2 id="Add-Digits"><a href="#Add-Digits" class="headerlink" title="Add Digits"></a>Add Digits</h2><p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
<p>For example:</p>
<p>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.    </p>
<p>我用了递归的方法，当结果是两位数时继续相加，当为个位数是开始返回。</p>
<pre><code>class Solution {
public:
    int addDigits(int num) {
        if(num&gt;=10)
            return addDigits(num/10+num%10);
        else
            return num;
    }
};
</code></pre><p>后来，在网上找更优的解法，发现下面这个算法。</p>
<pre><code>// Let&apos;s observe the pattern
//    1    1
//    2    2
//    ... ...
//    8    8    
//    9    9    
//    10    1
//    11    2
//    12    3    
//    ... ...
//    17    8
//    18    9
//    19    1
//    20    2
//    ...  ...
// It looks most of number just simply %9 is the answer, 
// but there are some edge cases.
//    9%9=0 but we need 9. 
//    18%9=0 but we need 9
// so we can find the solution is:
//    1) num &lt;=9, return num
//    2) num &gt; 9, reutrn num%9 if num%9&gt;0
//                return 9 if num%9 ==0
int addDigits03(int num) {
    return num &gt;9 ? ((num %9)==0 ? 9:num%9) : num;
}

//But actually, we can use (num-1)%9 + 1 to make all cases right.
int addDigits04(int num){
    return (num - 1) % 9 + 1;
}

//This solution is similar with pervious solution.
int addDigits05(int num){
    return num - 9 * ((num - 1)/9);
}
</code></pre><p>上面这三个算法，都是同一种思路，发现当给定的数不是9的倍数时，结果是该数%9的结果，否则结果是9。</p>
<h2 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {

        if(root==NULL)
        return 0;

        int left = maxDepth(root-&gt;left);
        int right = maxDepth(root-&gt;right);

        if(left&gt;right)
            return left+1;
        else
            return right+1;
    }
};
</code></pre><p>利用递归的方法，每层的深度是左子树与右子树中高的那个加一。</p>
<h2 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h2><p>Reverse a singly linked list.</p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<p>迭代方法（iteratively）：</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head){

        if(head==NULL||head-&gt;next==NULL) return head;

        ListNode *newN = head; // 新排序好的第一个
        ListNode *oldN = newN-&gt;next; // 待排序的第一个
        head -&gt; next = NULL;  // 将头结点的next清空
        ListNode *tempN = NULL; // 定义一个临时变量存储oldN的下一个

        while(oldN) // 不断将结点的next反向
        {
            tempN = oldN-&gt;next;
            oldN-&gt;next = newN;
            newN = oldN;
            oldN = tempN;
        }

        return newN;
    }
};
</code></pre><p>递归方法（recursively）：</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head){
        if (head==NULL || head-&gt;next==NULL) return head;

        ListNode *h = reverseList(head-&gt;next);
        head-&gt;next-&gt;next = head;
        head-&gt;next = NULL;

        return h;
    }
};
</code></pre><p>递归方法简单易懂。</p>
<h2 id="Counting-Bits"><a href="#Counting-Bits" class="headerlink" title="Counting Bits"></a>Counting Bits</h2><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>计算从0到num一共num+1个数，每个数的二进制形式中1的个数，组成一个数组。</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; countBits(int num) {
        vector&lt;int&gt; temp(num+1, 0);

        for (int i=0;i&lt;num+1;i++)
        {
            temp[i]=numOf1(i);
        }

        return temp;

    }
    int numOf1(int n) // 剑指offer书里介绍的一种非常巧妙地计算一个二进制数中1的个数的算法
    {
        int count = 0;
        while(n)
        {
            ++ count;
            n = n &amp; (n-1);
        }

        return count;
    }
};
</code></pre><h2 id="Invert-Binary-Tree"><a href="#Invert-Binary-Tree" class="headerlink" title="Invert Binary Tree"></a>Invert Binary Tree</h2><p>Invert a binary tree.</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9
</code></pre><p>to</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1
</code></pre><p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.（2333333333</p>
<p>递归算法：</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==NULL)return root;

        TreeNode *temp = invertTree(root-&gt;left); // 将左边的保存
        root-&gt;left = invertTree(root-&gt;right); // 左右互换
        root-&gt;right = temp;

        return root;   
    }
};
</code></pre><h2 id="Sum-of-Two-Integers"><a href="#Sum-of-Two-Integers" class="headerlink" title="Sum of Two Integers"></a>Sum of Two Integers</h2><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example:<br>Given a = 1 and b = 2, return 3.</p>
<p>要求不使用+或者-实现两个整数的加法运算，可以运用全加器的思想实现这个算法。<br>对于单独的两个一位二进制数，有两个输出，一个是本位输出，一个是进位输出。</p>
<pre><code>class Solution {
public:
    int getSum(int a, int b) {
        while(b)
        {
            int c = a &amp; b; //进位
            a = a ^ b; //本位
            b = c&lt;&lt;1; // 进位左移进入下一位的运算
        }
        return a;
    }
};
</code></pre><p>ex:a=0101(5),b=0011(3)</p>
<ul>
<li>c=0001,a=0110,b=0010</li>
<li>c=0010,a=0100,b=0100</li>
<li>c=0100,a=0000,b=1000</li>
<li>c=0000,a=1000,b=0000</li>
</ul>
<p>返回1000(8)</p>
<h2 id="Single-Number-III"><a href="#Single-Number-III" class="headerlink" title="Single Number III"></a>Single Number III</h2><p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>我们已经知道,假如题目为只有一个数为单次,其余都为两次时,可以用result = result ^ nums[i]找出result,所以本题中当有两个数为单次时,全部异或的结果allxor为a ^ b.</p>
<p>这时设一个标记tag,tag为a和b从低位开始,第一个不相等的那一位(例如a:0101和b:0011,tag为0010),由这个标记可以将整个数组分为需要的两大部分,然后由异或得出两个结果a和b.</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {
        int allxor = 0;
        for(int i=0;i&lt;nums.size();i++)
        {
            allxor = allxor ^ nums[i];
        }

        int tag = 1;
        while((allxor&amp;tag) == 0)
        {
            tag = tag&lt;&lt;1;
        }

        int a = 0;
        int b = 0;
        for(int i=0;i&lt;nums.size();i++)
        {
            if(tag&amp;nums[i])
            {
                a = a ^ nums[i];
            }
            else
            {
                b = b ^ nums[i];
            }
        }

        vector&lt;int&gt; result;
        result.push_back(a);
        result.push_back(b);

        return result;
    }
};
</code></pre><h2 id="Move-Zeroes"><a href="#Move-Zeroes" class="headerlink" title="Move Zeroes"></a>Move Zeroes</h2><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p>Note:</p>
<p>You must do this in-place without making a copy of the array.(空间复杂度O(1))</p>
<p>Minimize the total number of operations.</p>
<p>这个题要求空间复杂度为O(1),就不能创建一个新的空间生成新数组,只能在原来的空间上进行操作,可以设两个标记p1,p2.  p1为原顺序,p2为不为零的数的顺序,每当遇到0,p2++,就是将后面的所有数提前一个,当所有这种操作完成后,数组中就不存在0,然后将0补在数组的后面.</p>
<pre><code>class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int p1 = 0, p2 = 0;

        while(nums[p1] != 0 &amp;&amp; p1 &lt; nums.size()) //找到第一个为0的数的位置
        {
            p1++;
        }

        for(p2 = p1; p2&lt;nums.size(); p2++) //每当遇到0,p2++,将后面的数提前一位
        {
            if(nums[p2] == 0) continue;
            nums[p1] = nums[p2];
            p1++;
        }

        while(p1&lt;nums.size()) //补0
        {
            nums[p1] = 0;
            p1++;
        }
    }
};
</code></pre><h2 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a>Intersection of Two Arrays</h2><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example:</p>
<p>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>
<p>Note:</p>
<ul>
<li>Each element in the result must be unique.</li>
<li>The result can be in any order.</li>
</ul>
<p>在C++中,STL定义了许多容器,将vector转为set可以将重复的元素去除掉,所以本题可以用两个set,然后将set重新转为vector</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        set&lt;int&gt; s1;
        set&lt;int&gt; s2;
        vector&lt;int&gt; result;

        for(int i = 0; i &lt; nums1.size(); i++)
        {
            s1.insert(nums1[i]);
        }

        for(int i = 0; i &lt; nums2.size(); i++)
        {
            if (s1.find(nums2[i]) != s1.end())
            {
                s2.insert(nums2[i]);
            }
        }

        for(set&lt;int&gt;::iterator it = s2.begin(); it != s2.end(); it++)
        {
            result.push_back(*it);
        }

        return result;
    }
};
</code></pre><h2 id="Delete-Node-in-a-Linked-List"><a href="#Delete-Node-in-a-Linked-List" class="headerlink" title="Delete Node in a Linked List"></a>Delete Node in a Linked List</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.</p>
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val = node-&gt;next-&gt;val;
        node-&gt;next = node-&gt;next-&gt;next;
    }
};
</code></pre><h2 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a>Product of Array Except Self</h2><p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Solve it without division and in O(n).</p>
<p>For example, given [1,2,3,4], return [24,12,8,6].</p>
<p>Follow up:<br>Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)</p>
<p>题目限定了我们不能用除法,时间复杂度为O(n),空间复杂度为O(1),可以先正序遍历一遍数组，每一个位置上存这个位置之前所有数字的乘积。那么一遍下来，最后一个位置上的数字是之前所有数字之积,此时再后序遍历数组，每个位置上的数在乘以后面所有数字之积，对于最后一个位置来说，由于后面没有数字了，所以乘以1。</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; output(nums.size(),1);

        for(int i=1;i&lt;nums.size();i++)
        {
            output[i]=output[i-1]*nums[i-1];
        }

        int right=1;
        for(int i=nums.size()-1;i&gt;=0;i--)
        {
            output[i] *= right;
            right *= nums[i];
        }

        return output;
    }
};
</code></pre><h2 id="Same-Tree"><a href="#Same-Tree" class="headerlink" title="Same Tree"></a>Same Tree</h2><p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<p>这个题明显可以用递归的方法解决,不过要考虑两种特殊的情况,当都是空的时候是真的,当有一个空的时候是假的.</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p &amp;&amp; !q) return true;
        if(!p || !q) return false;
        return (p-&gt;val==q-&gt;val)&amp;&amp;(isSameTree(p-&gt;left,q-&gt;left))&amp;&amp;(isSameTree(p-&gt;right,q-&gt;right));
    }
};
</code></pre><h2 id="Excel-Sheet-Column-Title"><a href="#Excel-Sheet-Column-Title" class="headerlink" title="Excel Sheet Column Title"></a>Excel Sheet Column Title</h2><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<ul>
<li>1 -&gt; A</li>
<li>2 -&gt; B</li>
<li>3 -&gt; C</li>
<li>…</li>
<li>26 -&gt; Z</li>
<li>27 -&gt; AA</li>
<li>28 -&gt; AB </li>
</ul>
<p>注意当这个数能被26整除时,要-1防止多出现一个A</p>
<pre><code>class Solution {
public:
    string convertToTitle(int n) {
        string res;
        while(n&gt;0)
        {
            char ch = &apos;A&apos; + (n-1)%26;
            res.insert(res.begin(), ch);
            if(n%26==0) n=n-1;
            n /= 26;
        }

        return res;
    }
};
</code></pre><h2 id="Valid-Anagram"><a href="#Valid-Anagram" class="headerlink" title="Valid Anagram"></a>Valid Anagram</h2><p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>
<p>For example,<br>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p>
<pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        sort(s.begin(),s.end());
        sort(t.begin(),t.end());
        return s==t;
    }
};
</code></pre><h2 id="Fizz-Buzz"><a href="#Fizz-Buzz" class="headerlink" title="Fizz Buzz"></a>Fizz Buzz</h2><p>Write a program that outputs the string representation of numbers from 1 to n.</p>
<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>
<p>Example:</p>
<pre><code>n = 15,

Return:
[
    &quot;1&quot;,
    &quot;2&quot;,
    &quot;Fizz&quot;,
    &quot;4&quot;,
    &quot;Buzz&quot;,
    &quot;Fizz&quot;,
    &quot;7&quot;,
    &quot;8&quot;,
    &quot;Fizz&quot;,
    &quot;Buzz&quot;,
    &quot;11&quot;,
    &quot;Fizz&quot;,
    &quot;13&quot;,
    &quot;14&quot;,
    &quot;FizzBuzz&quot;
]
</code></pre><p>JS代码如下:</p>
<pre><code>/**
 * @param {number} n
 * @return {string[]}
 */
var fizzBuzz = function(n) {
    var arr = [];
    var str = &quot;&quot;;
    for(var i = 0; i &lt; n; i++) {
        str = &quot;&quot;;
        if((i+1)%3 === 0)  str += &quot;Fizz&quot;;
        if((i+1)%5 === 0)  str += &quot;Buzz&quot;;
        if(!str) str += i+1;
        arr.push(str);
    }
    return arr;

};
</code></pre>
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/26/Markdown入门/" rel="next" title="Markdown基本介绍">
                <i class="fa fa-chevron-left"></i> Markdown基本介绍
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/10/Hexo-NexT主题/" rel="prev" title="Hexo-NexT主题">
                Hexo-NexT主题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/06/27/LeetCode题解/"
           data-title="LeetCode题解" data-url="http://yoursite.com/2016/06/27/LeetCode题解/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ww4.sinaimg.cn/mw690/719c39c3gw1f4jhs5r30dj206o06o74c.jpg"
               alt="李普阳" />
          <p class="site-author-name" itemprop="name">李普阳</p>
          <p class="site-description motion-element" itemprop="description">一个人的命运啊，当然要靠自我奋斗。但是，也要考虑到历史的行程。（手动滑稽</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/p/1005053917294273/home?from=page_100505&mod=TAB&is_all=1#place" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Reverse-String"><span class="nav-number">1.</span> <span class="nav-text">Reverse String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nim-Game"><span class="nav-number">2.</span> <span class="nav-text">Nim Game</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Single-Number"><span class="nav-number">3.</span> <span class="nav-text">Single Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Add-Digits"><span class="nav-number">4.</span> <span class="nav-text">Add Digits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maximum-Depth-of-Binary-Tree"><span class="nav-number">5.</span> <span class="nav-text">Maximum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reverse-Linked-List"><span class="nav-number">6.</span> <span class="nav-text">Reverse Linked List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Counting-Bits"><span class="nav-number">7.</span> <span class="nav-text">Counting Bits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Invert-Binary-Tree"><span class="nav-number">8.</span> <span class="nav-text">Invert Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sum-of-Two-Integers"><span class="nav-number">9.</span> <span class="nav-text">Sum of Two Integers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Single-Number-III"><span class="nav-number">10.</span> <span class="nav-text">Single Number III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Move-Zeroes"><span class="nav-number">11.</span> <span class="nav-text">Move Zeroes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Intersection-of-Two-Arrays"><span class="nav-number">12.</span> <span class="nav-text">Intersection of Two Arrays</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Delete-Node-in-a-Linked-List"><span class="nav-number">13.</span> <span class="nav-text">Delete Node in a Linked List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Product-of-Array-Except-Self"><span class="nav-number">14.</span> <span class="nav-text">Product of Array Except Self</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Same-Tree"><span class="nav-number">15.</span> <span class="nav-text">Same Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Excel-Sheet-Column-Title"><span class="nav-number">16.</span> <span class="nav-text">Excel Sheet Column Title</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Valid-Anagram"><span class="nav-number">17.</span> <span class="nav-text">Valid Anagram</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fizz-Buzz"><span class="nav-number">18.</span> <span class="nav-text">Fizz Buzz</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李普阳</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>
        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"pangzili"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  

</body>
</html>
